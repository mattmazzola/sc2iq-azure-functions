export interface IEntity {
    id: number;
}
export interface IParsedEntity {
    id: string;
}
export interface IUnitReference extends IEntity {
    name: string;
}
export interface IParsedUnitReference extends IParsedEntity {
    name: string;
}
export interface IParsedUnit extends IParsedEntity {
    meta: IParsedMeta;
    life: IParsedHealth;
    armor: IParsedHealth;
    shields: IParsedHealth;
    shieldArmor: IParsedHealth;
    requires: IParsedRequires;
    cost: IParsedCost;
    movement: IParsedMovement;
    score: IParsedScore;
    misc: IParsedMisc;
    producer: IParsedUnitReference;
    attributes: IParsedAttributes;
    strengths: IParsedStrengths;
    weaknesses: IParsedWeaknesses;
    weapons: IParsedWeapons;
    abilities: IParsedAbilities;
    builds: IParsedBuilds;
    trains: IParsedTrains;
    upgrades: IParsedUpgrades;
    researches: IParsedBuildingUpgrades;
}
export interface IUnit extends IEntity {
    meta: IMeta;
    life: IHealth;
    armor: IHealth;
    shieldArmor: IHealth;
    requires: IUnitReference[];
    cost: ICost;
    movement: IMovement;
    score: IScore;
    misc: IMisc;
    producer: IUnitReference;
    attributes: IAttribute[];
    strengths: IUnitReference[];
    weaknesses: IUnitReference[];
    weapons: IWeapon[];
    abilities: IAbility[];
    builds: IUnit[];
    trains: IUnit[];
    upgrades: IUpgrade[];
    researches: IBuildingUpgrade[];
}
export interface IUnitNode extends IEntity {
    meta: IMeta;
    life: IHealth;
    armor: IHealth;
    shieldArmor: IHealth;
    requires: number[];
    cost: ICost;
    movement: IMovement;
    score: IScore;
    misc: IMisc;
    producer: number;
    attributes: IAttribute[];
    strengths: number[];
    weaknesses: number[];
    weapons: number[];
    abilities: number[];
    builds: number[];
    trains: number[];
    upgrades: number[];
    researches: number[];
}
export declare function convertUnit(parsedUnit: IParsedUnit): IUnit;
export declare const RaceMap: {
    "Zerg": string;
    "Prot": string;
    "Terr": string;
    "Neut": string;
};
export interface IParsedMeta {
    name: string;
    icon: string;
    race: string;
    hotkey: string;
    source: string;
    index: string;
    tooltip: string;
}
export interface IMeta {
    name: string;
    icon: string;
    race: string;
    hotkey: number;
    source: string;
    index: number;
    tooltip: number;
}
export declare function convertMeta(parsedMeta: IParsedMeta): IMeta;
export interface IParsedHealth {
    start: string;
    max: string;
    regenRate: string;
    delay: string;
}
export interface IHealth {
    start: number;
    max: number;
    regenRate: number;
    delay: number;
}
export declare function convertHealth(parsedHealth: IParsedHealth): IHealth;
export interface IParsedCost {
    minerals: string;
    vespene: string;
    time: string;
    supply: string;
}
export interface ICost {
    minerals: number;
    vespene: number;
    time: number;
    supply: number;
}
export declare function convertCost(parsedCost: IParsedCost): ICost;
export interface IParsedMovement {
    speed: string;
    acceleration: string;
    deceleration: string;
    turnRate: string;
}
export interface IMovement {
    speed: number;
    acceleration: number;
    deceleration: number;
    turnRate: number;
}
export declare function convertMovement(parsedMovement: IParsedMovement): IMovement;
export interface IParsedScore {
    build: string;
    kill: string;
}
export interface IScore {
    build: number;
    kill: number;
}
export declare function convertScore(parsedScore: IParsedScore): IScore;
export interface IParsedMisc {
    radius: string;
    cargoSize: string;
    footprint: string;
    sightRadius: string;
    supply: string;
    speed: number;
    targets: string;
}
export interface IMisc {
    radius: number;
    cargoSize: number;
    footprint: string;
    sightRadius: number;
    supply: number;
    speed: number;
    targets: string;
}
export declare function convertMisc(parsedMisc: IParsedMisc): IMisc;
export interface IParsedAttributes {
    attribute: IAttribute | IAttribute[];
}
export interface IAttribute {
    type: string;
}
export interface IParsedStrengths {
    unit: IParsedUnitReference[];
}
export interface IParsedRequires {
    unit?: IParsedUnitReference | IParsedUnitReference[];
    upgrade?: IParsedUnitReference | IParsedUnitReference[];
}
export interface IParsedBuilds {
    unit: IParsedUnit[];
}
export interface IParsedTrains {
    unit: IParsedUnit[];
}
export declare function convertUnitReference(parsedUnitReference: IParsedUnitReference): IUnitReference;
export declare function convertOneOrMore<T>(parsedInput: T | T[]): T[];
export interface IParsedWeaknesses {
    unit: IParsedUnitReference[];
}
export interface IParsedWeapons {
    weapon: IParsedWeapon[];
}
export interface IParsedWeapon {
    id: string;
    index: string;
    meta: IParsedMeta;
    misc: IParsedWeaponMisc;
    effect: IParsedEffect;
}
export interface IWeapon {
    id: number;
    index: number;
    meta: IMeta;
    misc: IWeaponMisc;
    effect: IEffect;
}
export declare function convertWeapon(parsedWeapon: IParsedWeapon): IWeapon;
export interface IParsedWeaponMisc {
    range: string;
    speed: string;
    targets: string;
}
export interface IWeaponMisc {
    range: number;
    speed: number;
    targets: string;
}
export declare function convertWeaponMisc(parsedWeaponMisc: IParsedWeaponMisc): IWeaponMisc;
export interface IParsedEffect {
    id: string;
    index: string;
    radius: string;
    damage: string;
    max: string;
    death: string;
    kind: string;
    bonus: IParsedBonus;
}
export interface IEffect {
    id: string;
    index: number;
    radius: number;
    max: number;
    death: string;
    kind: string;
    bonus: IBonus;
}
export declare function convertEffect(parsedEffect: IParsedEffect): IEffect;
export interface IParsedBonus {
    damage: string;
    max: string;
    type: string;
}
export interface IBonus {
    damage: number;
    max: number;
    type: string;
}
export declare function convertBonus(parsedBonus: IParsedBonus): IBonus;
export interface IParsedAbilities {
    ability: IAbility[];
}
export interface IAbility {
}
export interface IParsedUpgrades {
    upgrade: IParsedUpgrade[];
}
export interface IParsedUpgrade {
    id: string;
    index: string;
    level: IParsedUpgradeLevel | IParsedUpgradeLevel[];
}
export interface IParsedBuildingUpgrades {
    upgrade: IParsedBuildingUpgrade[];
}
export interface IUpgrade {
    id: string;
    index: number;
    levels: IUpgradeLevel[];
}
export declare function convertUpgrade(parsedUpgrade: IParsedUpgrade): IUpgrade;
export interface IParsedUpgradeLevel {
    id: string;
    index: string;
    requires: IParsedLevelRequires;
    meta: IParsedMeta;
    cost: IParsedCost;
}
export interface IUpgradeLevel {
    id: string;
    index: number;
    requires: ILevelRequires;
    meta: IMeta;
    cost: ICost;
}
export declare function convertUpgradeLevel(parsedUpgradeLevel: IParsedUpgradeLevel): IUpgradeLevel;
export interface IParsedLevelRequires {
    upgrade: IParsedUnitReference;
    unit: IParsedUnitReference;
}
export interface ILevelRequires {
    upgrade: IUnitReference;
    unit: IUnitReference;
}
export declare function convertLevelRequires(parsedLevelRequires: IParsedLevelRequires): ILevelRequires;
export interface IParsedBuildingUpgrade {
    id: string;
    index: string;
    ability: string;
    meta: IParsedMeta;
    cost: IParsedCost;
}
export interface IBuildingUpgrade {
    id: number;
    index: number;
    ability: number;
    meta: IMeta;
    cost: ICost;
}
export declare function convertBuildingUpgrade(parsedBuildingUpgrade: IParsedBuildingUpgrade): IBuildingUpgrade;
